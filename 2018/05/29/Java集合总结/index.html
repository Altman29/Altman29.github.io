<!doctype html>



  

<html class="theme-next mist use-motion">

<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java集合," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Java集合简介Java集合大致分为Set、List、Queue和Map四种体系。
其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java5中增加了Queue体系集合，代表一种队列集合实现。
Java集合就像一个容器，可以把多个对象，实际上是对象的引用，但习惯上都称对象，丢进容器中。从Java5增加了泛型以后、Java集合可以记住容器中对象的数">
<meta property="og:type" content="article">
<meta property="og:title" content="关于Java集合的综述">
<meta property="og:url" content="http://yoursite.com/2018/05/29/Java集合总结/index.html">
<meta property="og:site_name" content="拾叁妖">
<meta property="og:description" content="Java集合简介Java集合大致分为Set、List、Queue和Map四种体系。
其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java5中增加了Queue体系集合，代表一种队列集合实现。
Java集合就像一个容器，可以把多个对象，实际上是对象的引用，但习惯上都称对象，丢进容器中。从Java5增加了泛型以后、Java集合可以记住容器中对象的数">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java001.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java002.jpg">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java003.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java004.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java005.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java006.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java007.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/arraylist001.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/arraylist002.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/linkedlist001.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/hashmap001.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/hashmap002.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/hashmap003.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/hashmap004.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/hashmap005.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/linkedhashmap001.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/treemap001.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/treemap002.png">
<meta property="og:image" content="http://ogo6z0ylk.bkt.clouddn.com/treemap003.png">
<meta property="og:updated_time" content="2018-08-01T09:57:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于Java集合的综述">
<meta name="twitter:description" content="Java集合简介Java集合大致分为Set、List、Queue和Map四种体系。
其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java5中增加了Queue体系集合，代表一种队列集合实现。
Java集合就像一个容器，可以把多个对象，实际上是对象的引用，但习惯上都称对象，丢进容器中。从Java5增加了泛型以后、Java集合可以记住容器中对象的数">
<meta name="twitter:image" content="http://ogo6z0ylk.bkt.clouddn.com/Java001.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>

  <title> 关于Java集合的综述 | 拾叁妖 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">拾叁妖</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                关于Java集合的综述
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-29T10:50:47+08:00" content="2018-05-29">
              2018-05-29
            </time>
          </span>

          

          
            
          

          
          
          
          
             <span id="/2018/05/29/Java集合总结/" class="leancloud_visitors" data-flag-title="关于Java集合的综述">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java集合简介"><a href="#Java集合简介" class="headerlink" title="Java集合简介"></a>Java集合简介</h2><p>Java集合大致分为Set、List、Queue和Map四种体系。</p>
<p>其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java5中增加了Queue体系集合，代表一种队列集合实现。</p>
<p>Java集合就像一个容器，可以把多个对象，实际上是对象的引用，但习惯上都称对象，丢进容器中。从Java5增加了泛型以后、Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。<br><a id="more"></a></p>
<h3 id="Java集合和数组的区别"><a href="#Java集合和数组的区别" class="headerlink" title="Java集合和数组的区别"></a>Java集合和数组的区别</h3><p>数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存居右映射关系的数据。</p>
<p>数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象，实际上是保存对象的应用变量，基本数据类型的变量要转换成对应的包装类才能放入集合类中。</p>
<h3 id="Java集合之间的继承关系"><a href="#Java集合之间的继承关系" class="headerlink" title="Java集合之间的继承关系"></a>Java集合之间的继承关系</h3><p>Java集合类主要由俩个接口派生而出：Collection和Map，Collection和Map是集合框架的根接口。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java001.png" alt=""></p>
<p>图中，ArrayList、HashSet。LinkedList、TreeSet是经常会用到的已实现的集合类。</p>
<p>Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value俩个值组成的。Map里的key是不可重复的，key用户标识集合里的每项数据。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java002.jpg" alt=""></p>
<p>图中，HashMap、TreeMap是经常用到的集合类。</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="Collection简介"><a href="#Collection简介" class="headerlink" title="Collection简介"></a>Collection简介</h3><p>Collection接口是Set、Queue、List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。由于方法比较多，直接上JDK文档的截图。</p>
<h4 id="接口中定义的方法"><a href="#接口中定义的方法" class="headerlink" title="接口中定义的方法"></a>接口中定义的方法</h4><p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java003.png" alt=""></p>
<p>可以看出Collection用法有：添加元素、删除元素。返回Collection集合的个数以及清空集合等。</p>
<p>其中重点介绍iterator()方法，该方法的返回值是iterator。</p>
<h4 id="使用Iterator遍历集合元素"><a href="#使用Iterator遍历集合元素" class="headerlink" title="使用Iterator遍历集合元素"></a>使用Iterator遍历集合元素</h4><p>Iterator接口经常被称作迭代器，它是Collection接口的父接口。但iterator主要用于遍历集合中的元素。</p>
<p>Iterator接口中主要定义了2个方法：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java004.png" alt=""></p>
<p>下面程序简单示范了通过Iterator对象逐个获取元素的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorExample</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="comment">//创建集合，添加元素</span></div><div class="line">		Collection&lt;Day&gt; days = <span class="keyword">new</span> ArrayList&lt;Day&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">			Day day = <span class="keyword">new</span> Day(i,i*<span class="number">60</span>,i*<span class="number">3600</span>);</div><div class="line">			days.add(day);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//获取days集合的迭代器</span></div><div class="line">		Iterator&lt;Day&gt; iterator = days.iterator();</div><div class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//判断是否有下一个元素</span></div><div class="line">			Day next = iterator.next();<span class="comment">//取出该元素</span></div><div class="line">			<span class="comment">//逐个遍历，取得元素后进行后续操作</span></div><div class="line">			<span class="comment">//....</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，当使用iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量，就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量。</p>
<p>下面的demo演示了这一点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorExample</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</div><div class="line">		List&lt;MyObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">			list.add(<span class="keyword">new</span> MyObject(i));</div><div class="line">		&#125;</div><div class="line">		System.out.println(list.toString());</div><div class="line">		<span class="comment">//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址</span></div><div class="line">		Iterator&lt;MyObject&gt; iterator = list.iterator();</div><div class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">			MyObject next = iterator.next();</div><div class="line">			next.num = <span class="number">99</span>;</div><div class="line">		&#125;</div><div class="line">		System.out.println(list.toString());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> num;</div><div class="line"></div><div class="line">		MyObject(<span class="keyword">int</span> num)&#123;</div><div class="line">			<span class="keyword">this</span>.num = num;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> String.valueOf(num);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<blockquote>
<p>[0,1,2,3,4,5,6,7,8,9]<br>[99, 99, 99, 99, 99, 99, 99, 99, 99, 99]</p>
</blockquote>
<p>下面具体介绍Collection接口的三个子类接口Set、List、Queue。</p>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>Set集合与Collection集合基本相同，没有提供额外的方法。实际上Set就是Collection，只是行为策略不同，Set不允许包含重复元素。</p>
<p>Set集合不允许包含相同的元素，如果试图把来个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</p>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><h4 id="List简介"><a href="#List简介" class="headerlink" title="List简介"></a>List简介</h4><p>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引，索引从0开始。</p>
<p>List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合的方法。</p>
<h4 id="接口中定义的方法-1"><a href="#接口中定义的方法-1" class="headerlink" title="接口中定义的方法"></a>接口中定义的方法</h4><blockquote>
<p>void add(int index, Object element): 在列表的指定位置插入指定元素（可选操作）。<br>boolean addAll(int index, Collection&lt;? extends E&gt; c) : 将集合c 中的所有元素都插入到列表中的指定位置index处。<br>Object get(index): 返回列表中指定位置的元素。<br>int indexOf(Object o): 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。<br>int lastIndexOf(Object o): 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。<br>Object remove(int index): 移除列表中指定位置的元素。<br>Object set(int index, Object element): 用指定元素替换列表中指定位置的元素。<br>List subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。<br>Object[] toArray(): 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。</p>
</blockquote>
<p>除此之外，Java8还为List接口添加了俩个方法。</p>
<blockquote>
<p>void replaceAll(UnaryOperator operator): 根据operator指定的计算规则重新设置List集合的所有元素。<br>void sort(Comparator c): 根据Comparator参数对List集合的元素排序。</p>
</blockquote>
<h3 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h3><h4 id="Queue简介"><a href="#Queue简介" class="headerlink" title="Queue简介"></a>Queue简介</h4><p>Queue用户模拟队列这种数据结构，队列通常是指”先进先出”(FIFO,First-in-first-out)的容器。队列的头部是再队列中存放时间最长的元素，队列的尾部是保存再队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p>
<h4 id="接口中定义的方法-2"><a href="#接口中定义的方法-2" class="headerlink" title="接口中定义的方法"></a>接口中定义的方法</h4><p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java005.png" alt=""></p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h3><p>Map用户保存具有映射关系的数据，因此Map集合里保存着俩组数，一组值用户保存Map里的key，另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何俩个key通过equals方法比较总是返回false。</p>
<p>key和value之间攥在单向一对一关系，即通过指定key，总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定key，就可以取出对应的value。</p>
<h3 id="Map集合与Set集合、List集合的关系"><a href="#Map集合与Set集合、List集合的关系" class="headerlink" title="Map集合与Set集合、List集合的关系"></a>Map集合与Set集合、List集合的关系</h3><h4 id="与Set集合的关系"><a href="#与Set集合的关系" class="headerlink" title="与Set集合的关系"></a>与Set集合的关系</h4><p>如果把Map里的所有key放在一起，他们就组成了一个Set集合，所有的key没有顺序，key与key之间不能重复。实际上Map确实包含一个keySet()方法，用户返回Map里的所有key组成的Set集合。</p>
<h4 id="与List集合的关系"><a href="#与List集合的关系" class="headerlink" title="与List集合的关系"></a>与List集合的关系</h4><p>如果把Map里的所有value放在一起看，他们又非常类似于一个List:元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。</p>
<h3 id="接口中定义的方法-3"><a href="#接口中定义的方法-3" class="headerlink" title="接口中定义的方法"></a>接口中定义的方法</h3><p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java006.png" alt=""></p>
<p>Map中还包括一个内部类Entry，该类分装了一个key-value对。Entry包含如下三个方法。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/Java007.png" alt=""></p>
<p>Map集合典型的用法就是成对的添加、删除key-value对，然后就是判断该Map中是否包含指定key，是否包含指定value，也可以通过Map提供keySet()方法获取所有的key组成的集合，然后使用foreach循环来遍历Map的所有key，根据key即可遍历所有的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirngp[] args)</span></span>&#123;</div><div class="line">		Day day1 = <span class="keyword">new</span> Day(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">		Day day2 = <span class="keyword">new</span> Day(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line">		Map&lt;String,Day&gt; map = <span class="keyword">new</span> HashMap&lt;String,Day&gt;();</div><div class="line">		<span class="comment">//成对放入key-value对</span></div><div class="line">		map.put(<span class="string">"第一个"</span>,day1);</div><div class="line">		map.put(<span class="string">"第二个"</span>,day2);</div><div class="line">		<span class="comment">//判断是否包含指定的key</span></div><div class="line">		System.out.println(map.containsKey(<span class="string">"第一个"</span>));</div><div class="line">		<span class="comment">//判断是否包含指定的value</span></div><div class="line">		System.out.println(map.containsValue(day1));</div><div class="line">		<span class="comment">//循环遍历</span></div><div class="line">		<span class="comment">//1.获取Map中所有key组成的Set集合</span></div><div class="line">		Set&lt;String&gt; keySet = <span class="keyword">new</span> map.keySet();</div><div class="line">		<span class="comment">//2.使用foreach进行遍历</span></div><div class="line">		<span class="keyword">for</span>(String key : keySet)&#123;</div><div class="line">			<span class="comment">//根据key获取指定value</span></div><div class="line">			System.out.println(map.get(key));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//根据key来移除key-value对</span></div><div class="line">		map.remove(<span class="string">"第一个"</span>);</div><div class="line">		System.out.println(map);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<blockquote>
<p>true<br>true<br>Day [hour=2, minute=3, second=4]<br>Day [hour=1, minute=2, second=3]<br>{第二个=Day [hour=2, minute=3, second=4]}</p>
</blockquote>
<hr>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%的容量，用System.arraycopy()复制到新的数组，因此最后能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。按照数组下标访问元素get(i)/set(i,e)性能很高，这是数组的基本优势。直接再数组末尾添加元素add(e)性能也高，但如果按下标插入、删除元素add(i,e)，remove(i)，remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
</blockquote>
<p>ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是常说的动态数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list.add(<span class="string">"语文"</span>,<span class="number">99</span>);</div><div class="line">list.add(<span class="string">"数学"</span>,<span class="number">98</span>);</div><div class="line">list.add(<span class="string">"英语"</span>,<span class="number">99</span>);</div><div class="line">list.remove(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>在执行这四条语句时，是这么变化的。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/arraylist001.png" alt=""></p>
<p>其中，add操作可以理解为直接将数组的内容置位，remove操作可以理解为删除index为0的节点，并将后面元素移到0处。</p>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><p>当ArrayList增加元素的时候，会使用add函数。它会将元素放到末尾。具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</div><div class="line">	ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">//Increments modCount!</span></div><div class="line">	elementData[size++] = e;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到它的实现其实核心内容就是ensureCapacityInternal。这个函数其实就是自动扩容机制的核心。具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)&#123;</div><div class="line">		minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">	&#125;</div><div class="line">	ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">	modCount++;</div><div class="line">	<span class="comment">//overflow-conscious code</span></div><div class="line">	<span class="keyword">if</span>(minCapacity - elementData.legth &gt; <span class="number">0</span>)&#123;</div><div class="line">		grow(minCapacity)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">	<span class="comment">//overflow-conscious code</span></div><div class="line">	<span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">	<span class="comment">//扩展为原来的1.5倍</span></div><div class="line">	<span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity&gt;&gt;<span class="number">1</span>);</div><div class="line">	<span class="comment">//如果扩展为1.5倍不满足，直接扩为需求值</span></div><div class="line">	<span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)&#123;</div><div class="line">		newCapacity = minCapaticy;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)&#123;</div><div class="line">		newCapacity = hugeCapacity(minCapacity);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//minCapacity is usually close to size,so this is a win:</span></div><div class="line">	elementData = Array.copyOf(elementData,newCapacity);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，当增加数据时，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当add 10个元素后，再进行一次add时，就会发生自动扩容，数组长度由10变成15如下所示。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/arraylist002.png" alt=""></p>
<h3 id="set和get函数"><a href="#set和get函数" class="headerlink" title="set和get函数"></a>set和get函数</h3><p>Array的set和get函数比较简单，先做index检查，然后执行赋值或者访问操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">	E oldValue = elementData(index);</div><div class="line">	elementData[index] = element;</div><div class="line">	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">	rangeCheck(index;</div><div class="line">	<span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">	modCount++;</div><div class="line">	E oldValue = elementData(index);</div><div class="line">	<span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="comment">//把后面的往前移</span></div><div class="line">		System.arraycopy(elementData,index=<span class="number">1</span>,elementData,index,numMoved);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//把后面的置位null</span></div><div class="line">	elementData[--size] = <span class="keyword">null</span>;<span class="comment">//clear to let GC do its work</span></div><div class="line">	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多的空间，也需要额外的链表指针操作。<br>按下标访问元素 get(i)/set(i,e)要悲剧的遍历链表将指针移动到位，如果i&gt;数组大小的一半，会从末尾移动。<br>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表俩头的操作 add()，addFirst()，removeLast()或用iterator()上的remove能省掉指针的移动。</p>
</blockquote>
<p>LinkedList是一个简单的数据结构，与ArrayList不同的是，它是基于链表实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">list.add(<span class="string">"语文"</span>,<span class="number">1</span>);</div><div class="line">list.add(<span class="string">"数学"</span>,<span class="number">2</span>);</div><div class="line">list.add(<span class="string">"英语"</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>结构也相对简单，如下所示。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/linkedlist001.png" alt=""></p>
<h3 id="set和get函数-1"><a href="#set和get函数-1" class="headerlink" title="set和get函数"></a>set和get函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    E oldVal = x.item;</div><div class="line">    x.item = element;</div><div class="line">    <span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这俩个函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是判断index是在前半区还是后半区，如果再前半区就从head搜索，而在后半区就从tail搜索。而不是一直从头到位的搜索，如此设计，将节点访问的复杂度有O(n)变为O(n/2)。</p>
<hr>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>HashMap是基于哈希表的Map接口的非同步实现，此实现提供所有可选的映射操作，并允许使用null值和null健。此类不保证映射的顺序，特别是它不保证该顺序一直不变。<br>在Java中，最基本的结构就是俩种，一个是数组，一个是模拟指针(引用)，所有的数据结构都可用这俩个基本机构来构造，HashMap也不例外。HashMap实际上是一个”链表散列”的数据结构，即数组和链表的结合体。</p>
</blockquote>
<p>当执行下面的操作时:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line">map.put(<span class="string">"语文"</span>, <span class="number">1</span>);</div><div class="line">map.put(<span class="string">"数学"</span>, <span class="number">2</span>);</div><div class="line">map.put(<span class="string">"英语"</span>, <span class="number">3</span>);</div><div class="line">map.put(<span class="string">"历史"</span>, <span class="number">4</span>);</div><div class="line">map.put(<span class="string">"政治"</span>, <span class="number">5</span>);</div><div class="line">map.put(<span class="string">"地理"</span>, <span class="number">6</span>);</div><div class="line">map.put(<span class="string">"生物"</span>, <span class="number">7</span>);</div><div class="line">map.put(<span class="string">"化学"</span>, <span class="number">8</span>);</div><div class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果是:</p>
<blockquote>
<p>政治: 5<br>生物: 7<br>历史: 4<br>数学: 2<br>化学: 8<br>语文: 1<br>英语: 3<br>地理: 6</p>
</blockquote>
<p>下面是大致的结构，可以对HashMap的结构有个感性的认知:</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/hashmap001.png" alt=""></p>
<h3 id="俩个重要的参数"><a href="#俩个重要的参数" class="headerlink" title="俩个重要的参数"></a>俩个重要的参数</h3><p>在HashMap中有俩个很重要的参数，容量(Capacity)和负载因子(Load factor)</p>
<p>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求高的话，不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于 capacity * load factor时就需要调整bucket的大小为当前的2倍。(与ArrayList类似，但是多了一个负载因子。)</p>
<h3 id="put函数的实现"><a href="#put函数的实现" class="headerlink" title="put函数的实现"></a>put函数的实现</h3><p>put函数的大致思路：</p>
<blockquote>
<p>对key的hashCode()做hash，然后再计算index<br>如果没有碰撞，直接放在bucket里<br>如果碰撞了，以链表的形式存在buckets后<br>如果碰撞导致链表过长(大于TREEIFY_THRESHOLD)，就把链表转换成红黑树<br>如果节点已经存在就替换old Value(保证key的唯一性)<br>如果bucket满了(超过load factor * current capacity)，就要resize。</p>
</blockquote>
<p>具体代码实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value&#123;</span></span></div><div class="line">	//对key的hashCode()做hash</div><div class="line">	return <span class="title">putVal</span><span class="params">(hash(key)</span>,key,value,<span class="keyword">false</span>,<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash,K key,V value,<span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span></span>&#123;</div><div class="line">	<span class="comment">//Absent 缺席，evict 驱逐</span></div><div class="line">	Node&lt;K,V&gt;[] tab;Node&lt;K,V&gt; p;<span class="keyword">int</span> n, i;</div><div class="line">	<span class="comment">//tab为空则创建</span></div><div class="line">	<span class="keyword">if</span>((tab =table) == <span class="keyword">null</span> || (n = tab.length) ==<span class="number">0</span>)</div><div class="line">		n = (tab = resize()).length;</div><div class="line">	<span class="comment">//计算index，并对null做处理</span></div><div class="line">	<span class="keyword">if</span>((p = tab[i = (n -<span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">		tab[i] = newNode(hash, key,value,<span class="keyword">null</span>);</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		Node&lt;K,V&gt; e;K k;</div><div class="line">		<span class="comment">//节点存在</span></div><div class="line">		<span class="keyword">if</span>(p.hash == hash &amp;&amp; ((k = p.key) == key) || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))</div><div class="line">			e = p;</div><div class="line">		<span class="comment">//该链为树</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">			e = ((TreeNode&lt;K,V&gt; p).putTreeVal(<span class="keyword">this</span>,tab,hash,key,value));</div><div class="line">		<span class="comment">//该链为链表</span></div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> binCount =<span class="number">0</span> ; ; ++binCOunt)&#123;</div><div class="line">				<span class="keyword">if</span>((e = p.next) == <span class="keyword">null</span>)&#123;</div><div class="line">					p.next = newNode(hash,key,value,<span class="keyword">null</span>);</div><div class="line">					<span class="keyword">if</span>(binCount &gt;= TREEIFY_THRESHOLD -<span class="number">1</span>)<span class="comment">// -1 for 1st</span></div><div class="line">						treeifyBin(tab,hash);</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				p = e;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//写入</span></div><div class="line">		<span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123; <span class="comment">//existing mapping for key</span></div><div class="line">			V oldValue = e.value;</div><div class="line">			<span class="keyword">if</span>(!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">				e.value = value;</div><div class="line">			afterNodeAccess(e);</div><div class="line">			<span class="keyword">return</span> oldValue;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	++modCount;</div><div class="line">	<span class="comment">//超过load factor * current capacity , resize</span></div><div class="line">	<span class="keyword">if</span>(++size &gt; threshold)</div><div class="line">		resize();</div><div class="line">	afterNodeInsertion(evict);</div><div class="line">	reutrn <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get函数的实现"><a href="#get函数的实现" class="headerlink" title="get函数的实现"></a>get函数的实现</h3><p>在理解put之后，get就很简单了。大致思路如下：</p>
<blockquote>
<p>bucket里的第一个节点，直接命中；<br>如果有冲突，则通过key.equals(k)去查找对应的entry<br>若为树，则在树中通过key.equals(k) 查找,O(logn);<br>若为链表，则在链表中通过key.equals(k)查找，O(n);</p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 直接命中</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="comment">// 未命中</span></div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 在树中get</span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="comment">// 在链表中get</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="hash函数的实现"><a href="#hash函数的实现" class="headerlink" title="hash函数的实现"></a>hash函数的实现</h3><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/hashmap002.png" alt=""></p>
<p>在对hashCode()计算hash时具体实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。</p>
<p>在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(n - <span class="number">1</span>) &amp; hash</div></pre></td></tr></table></figure>
<p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</p>
<p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<p>之前已经提过，在获取HashMap的元素时，基本分两步：</p>
<blockquote>
<p>首先根据hashCode()做hash，然后确定bucket的index；<br>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找;</p>
</blockquote>
<p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</p>
<p>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。</p>
<h3 id="resize函数的实现"><a href="#resize函数的实现" class="headerlink" title="resize函数的实现"></a>resize函数的实现</h3><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。</p>
<p>当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p>
<p>例如我们从16扩展为32时，具体的变化如下所示：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/hashmap003.png" alt=""></p>
<p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/hashmap004.png" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/hashmap005.png" alt=""></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>
<p>下面是具体代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 计算新的resize上限</span></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">// 原索引</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// 原索引+oldCap</span></div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 原索引放到bucket里</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h3><p>我们现在可以回答几个问题，加深对HashMap的理解：</p>
<p><b>1. 什么时候会使用HashMap？他有什么特点？</b><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p>
<p><b>2. 你知道HashMap的工作原理吗？</b><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<p><b>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</b><br>通过对key的hashCode()进行hashing，并计算下标( (n-1) &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<p><b>4. 你知道hash的实现吗？为什么要这样实现？</b><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
<p><b>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</b><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p>
<hr>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>在理解了HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LinkedHashMap&lt;String, Integer&gt; lmap = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</div><div class="line">lmap.put(<span class="string">"语文"</span>, <span class="number">1</span>);</div><div class="line">lmap.put(<span class="string">"数学"</span>, <span class="number">2</span>);</div><div class="line">lmap.put(<span class="string">"英语"</span>, <span class="number">3</span>);</div><div class="line">lmap.put(<span class="string">"历史"</span>, <span class="number">4</span>);</div><div class="line">lmap.put(<span class="string">"政治"</span>, <span class="number">5</span>);</div><div class="line">lmap.put(<span class="string">"地理"</span>, <span class="number">6</span>);</div><div class="line">lmap.put(<span class="string">"生物"</span>, <span class="number">7</span>);</div><div class="line">lmap.put(<span class="string">"化学"</span>, <span class="number">8</span>);</div><div class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果是：</p>
<blockquote>
<p>语文: 1<br>数学: 2<br>英语: 3<br>历史: 4<br>政治: 5<br>地理: 6<br>生物: 7<br>化学: 8</p>
</blockquote>
<p>我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/linkedhashmap001.png" alt=""></p>
<p>LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p>
<h3 id="三个重点实现的函数"><a href="#三个重点实现的函数" class="headerlink" title="三个重点实现的函数"></a>三个重点实现的函数</h3><p>在HashMap中提到了下面的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。</p>
<p>afterNodeAccess函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="comment">// 如果定义了accessOrder，那么就保证最近访问节点放到最后</span></div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。</p>
<p>afterNodeInsertion函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="comment">// 如果定义了溢出规则，则执行相应的溢出</span></div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用户定义了removeEldestEntry的规则，那么便可以执行相应的移除操作。</p>
<p>afterNodeRemoval函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">    <span class="comment">// 从链表中移除节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">    p.before = p.after = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">        head = a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        b.after = a;</div><div class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">        tail = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数是在移除节点后调用的，就是将节点从双向链表中删除。</p>
<p>我们从上面3个函数看出来，基本上都是为了保证双向链表中的节点次序或者双向链表容量所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p>
<h3 id="put和get函数"><a href="#put和get函数" class="headerlink" title="put和get函数"></a>put和get函数</h3><p>put函数在LinkedHashMap中未重新实现，只是实现了afterNodeAccess和afterNodeInsertion两个回调函数。get函数则重新实现并加入了afterNodeAccess来保证访问顺序，下面是get函数的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">ublic V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，在accessOrder模式下，只要执行get或者put等操作的时候，就会产生structural modification。</p>
<p>总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。</p>
<hr>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>之前已经学习过HashMap和LinkedHashMap了，HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">TreeMap&lt;Integer, String&gt; tmap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</div><div class="line">tmap.put(<span class="number">1</span>, <span class="string">"语文"</span>);</div><div class="line">tmap.put(<span class="number">3</span>, <span class="string">"英语"</span>);</div><div class="line">tmap.put(<span class="number">2</span>, <span class="string">"数学"</span>);</div><div class="line">tmap.put(<span class="number">4</span>, <span class="string">"政治"</span>);</div><div class="line">tmap.put(<span class="number">5</span>, <span class="string">"历史"</span>);</div><div class="line">tmap.put(<span class="number">6</span>, <span class="string">"地理"</span>);</div><div class="line">tmap.put(<span class="number">7</span>, <span class="string">"生物"</span>);</div><div class="line">tmap.put(<span class="number">8</span>, <span class="string">"化学"</span>);</div><div class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其大致的结构如下所示：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/treemap001.png" alt=""></p>
<p>使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。具体红黑树的实现不在这里赘述，可以参考数据结构之红黑树、wikipedia-红黑树等的实现。</p>
<h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数"></a>put函数</h3><p>如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">        <span class="comment">// 如果该节点存在，则替换值直接返回</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果该节点未存在，则新建</span></div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line"></div><div class="line">    <span class="comment">// 红黑树平衡调整</span></div><div class="line">    fixAfterInsertion(e);</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><p>get函数则相对来说比较简单，以log(n)的复杂度进行get。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="comment">// 按照二叉树搜索的方式进行搜索，搜到返回</span></div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="successor后续"><a href="#successor后续" class="headerlink" title="successor后续"></a>successor后续</h3><p>TreeMap是如何保证其迭代输出是有序的呢？其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据The enhanced for statement，for语句会做如下转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = tmap.entrySet().iterator() ; tmap.hasNext(); ) &#123;</div><div class="line">    Entry&lt;Integer, String&gt; entry = it.next();</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在it.next()的调用中会使用nextEntry调用successor这个是过的后继的重点，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 有右子树的节点，后继节点就是右子树的“最左节点”</span></div><div class="line">        <span class="comment">// 因为“最左子树”是右子树的最小节点</span></div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点</span></div><div class="line">        <span class="comment">// 因为左子树找完了，根据LDR该D了</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="comment">// 保证左子树</span></div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下：</p>
<blockquote>
<p>a. 空节点，没有后继<br>b. 有右子树的节点，后继就是右子树的“最左节点”<br>c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点</p>
</blockquote>
<p>a.好理解，不过b, c，有点像绕口令啊，没关系，上图举个例子就懂了！</p>
<p>有右子树的节点，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是右子树的“最左节点”，就好像下图所示：</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/treemap002.png" alt=""></p>
<p>无右子树的节点，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。</p>
<p><img src="http://ogo6z0ylk.bkt.clouddn.com/treemap003.png" alt=""></p>
<hr>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java集合/" rel="tag">#Java集合</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/17/Java-Android-Menu/" rel="next" title="Java&Android Menu">
                <i class="fa fa-chevron-left"></i> Java&Android Menu
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/03/Syntactic-Sugar-in-Java/" rel="prev" title="Syntactic Sugar in Java">
                Syntactic Sugar in Java <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>

          
  <div class="comments" id="comments">
    
  </div>
  <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMTcxMS84Mjc1">
  <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/ava.png"
               alt="拾叁妖" />
          <p class="site-author-name" itemprop="name">拾叁妖</p>
          <p class="site-description motion-element" itemprop="description">奇变偶不变，符号看象限。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Altman29" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5866547818/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java集合简介"><span class="nav-number">1.</span> <span class="nav-text">Java集合简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java集合和数组的区别"><span class="nav-number">1.1.</span> <span class="nav-text">Java集合和数组的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java集合之间的继承关系"><span class="nav-number">1.2.</span> <span class="nav-text">Java集合之间的继承关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection接口"><span class="nav-number">2.</span> <span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection简介"><span class="nav-number">2.1.</span> <span class="nav-text">Collection简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口中定义的方法"><span class="nav-number">2.1.1.</span> <span class="nav-text">接口中定义的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Iterator遍历集合元素"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用Iterator遍历集合元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set集合"><span class="nav-number">2.2.</span> <span class="nav-text">Set集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List集合"><span class="nav-number">2.3.</span> <span class="nav-text">List集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List简介"><span class="nav-number">2.3.1.</span> <span class="nav-text">List简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口中定义的方法-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">接口中定义的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue集合"><span class="nav-number">2.4.</span> <span class="nav-text">Queue集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue简介"><span class="nav-number">2.4.1.</span> <span class="nav-text">Queue简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口中定义的方法-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">接口中定义的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map接口"><span class="nav-number">3.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map简介"><span class="nav-number">3.1.</span> <span class="nav-text">Map简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map集合与Set集合、List集合的关系"><span class="nav-number">3.2.</span> <span class="nav-text">Map集合与Set集合、List集合的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与Set集合的关系"><span class="nav-number">3.2.1.</span> <span class="nav-text">与Set集合的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与List集合的关系"><span class="nav-number">3.2.2.</span> <span class="nav-text">与List集合的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口中定义的方法-3"><span class="nav-number">3.3.</span> <span class="nav-text">接口中定义的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">4.</span> <span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add函数"><span class="nav-number">4.2.</span> <span class="nav-text">add函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set和get函数"><span class="nav-number">4.3.</span> <span class="nav-text">set和get函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove函数"><span class="nav-number">4.4.</span> <span class="nav-text">remove函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">5.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set和get函数-1"><span class="nav-number">5.2.</span> <span class="nav-text">set和get函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">6.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#俩个重要的参数"><span class="nav-number">6.2.</span> <span class="nav-text">俩个重要的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put函数的实现"><span class="nav-number">6.3.</span> <span class="nav-text">put函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get函数的实现"><span class="nav-number">6.4.</span> <span class="nav-text">get函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash函数的实现"><span class="nav-number">6.5.</span> <span class="nav-text">hash函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize函数的实现"><span class="nav-number">6.6.</span> <span class="nav-text">resize函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap总结"><span class="nav-number">6.7.</span> <span class="nav-text">HashMap总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">7.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-3"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个重点实现的函数"><span class="nav-number">7.2.</span> <span class="nav-text">三个重点实现的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put和get函数"><span class="nav-number">7.3.</span> <span class="nav-text">put和get函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">8.</span> <span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-4"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put函数"><span class="nav-number">8.2.</span> <span class="nav-text">put函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get函数"><span class="nav-number">8.3.</span> <span class="nav-text">get函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#successor后续"><span class="nav-number">8.4.</span> <span class="nav-text">successor后续</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >

  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">拾叁妖</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
  &nbsp;丨&nbsp;
  <!-- 不蒜统计 -->
  <span style="display: inline;" id="busuanzi_container_site_uv">本站总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span>
  &nbsp;丨&nbsp;
  <span style="display: inline;" id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span>
</div>




        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nfQNU5dFwiltiHNWVEeJeuFp-gzGzoHsz", "oANzCtO0CzmnL1JmWkHda5Dp");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
